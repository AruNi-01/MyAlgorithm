/*
题目：
此题是 70.爬楼梯 的进阶题，只需要将题目稍微改动一下，就是一个完全背包问题。
原题：
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

进阶：
    一步可以跳一个台阶，两个台阶，三个台阶，.......，直到跳m个台阶。问有多少种不同的方法可以爬到楼顶？
    1阶，2阶，.... m阶就是物品，楼顶n就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。
    问跳到楼顶有几种方法其实就是问装满背包有几种方法。
    到这里就可以发现这就是一个完全背包问题了。和 377. 组合总和Ⅳ 基本就是一道题了。

DP五部曲：
    1. 确定dp数组和其下标含义
        dp[i]: 爬到i个台阶的楼顶，有dp[i]种方法。
    2. 确定递推公式
        在 494.目标和、518.零钱兑换II、377. 组合总和 Ⅳ 中，求装满背包有几种方法，
        递推公式一般都是dp[i] += dp[i - nums[j]];
        本题dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]
        那么递推公式为：dp[i] += dp[i - j]
    3. dp数组如何初始化
        递推公式是dp[i] += dp[i - j]; 那么dp[0]一定为1，dp[0]是递推中一切数值的基础，
        如果dp[0]是0，其他数值都是0了。
        下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果。
    4. 确定遍历顺序
        背包求排列问题，需要将target放在外循环，将nums放在内循环。
        每一步可以走多次，这是完全背包，内循环需要从前向后遍历。
    5. 举例推导dp数组
        和 377. 组合总和Ⅳ 基本一致。
*/

class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        // 假设一次可以跳 1/2/3/4/5 步台阶
        int m = 5;
        for (int i = 0; i <= n; i++) {      // 遍历背包
            for (int j = 0; j < m; j++) {       // 遍历物品
                if (i >= j) {
                    dp[i] += dp[i - j];
                }
            }
        }
        return dp[n];
    }
}
// 代码中的m表示最多可以爬m个台阶，把m改为2就可以AC 70.爬楼梯 了。