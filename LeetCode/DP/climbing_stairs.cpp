/*
 * @Descripttion: 70. 爬楼梯
 * @Author: AruNi
 * @Date: 2022-05-25 14:17:26
 */

/*
题目：
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2：
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
*/

/*
思路：
    寻找规律：
        爬到第一层楼梯有1种方法，爬到第二层楼梯有2种方法。
        那么第一层楼梯再跨两步就到第三层，第二层楼梯再跨一步就到第三层。
        所以到第三层楼梯的状态可以由第二层楼梯和第一层楼梯状态推导出来，可以想到DP。
    DP 五部曲：
        1. 确定dp数组和其下标的含义
            dp[i]：爬到第 i 层楼梯，有 dp[i] 种方法
        2. 确定递推公式
            从dp[i]的定义可以看出，dp[i]有2个方向推导出来。
            首先是dp[i-1]，上i-1层楼梯，有dp[i-1]种方法，那么再一步跳一个台阶就是dp[i]了
            还有就是dp[i-2]，上i-2层楼梯，有dp[i-2]种方法，那么再一步跳两个台阶就是dp[i]了
            那么dp[i]就是dp[i-1]与dp[i-2]之和，所以dp[i]=dp[i-1]+dp[i-2];
        3. dp数组如何初始化
            题目说n是一个正数，所以不考虑dp[0]的初始化。只初始化dp[1]=1, dp[2]=2，然后从i=3开始递推。
        4. 确定遍历顺序
            从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的。
        5. 举例推导dp数组
            当n=5时，dp数组应该如下：
            下标i： 1   2   3   4   5
            dp[i]: 1   2   3   5   8
如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。

这不就是斐波那契数列么，哈哈哈！！！
唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！
*/
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {  // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};

// 和fib一样，也可以维护2个数值，降低空间复杂度
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {  // 注意i是从3开始的
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
