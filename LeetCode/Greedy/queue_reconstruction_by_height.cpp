/*
 * @Descripttion: 406. 根据身高重建队列
 * @Author: AruNi
 * @Date: 2022-05-21 21:20:31
 */

/*
题目：
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。
每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，
其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

示例 2：
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
*/

/*
本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。
和 135. 分发糖果 类似，如果两个维度一起考虑一定会顾此失彼。

如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。
那么按照身高h来排序，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。
为什么身高相同的话则k小的站前面？ 
因为后续插入的时候是按照k来插入，如果k大的在前面，后面k小的再插入就会插入在前面，那么k大的那个人
前面就多了一个和他身高相同的人，所以这样插入就会对结果造成影响。如果k小的在前面，就不会对k大的造成影响。

按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。
为什么排序后按照prople的k来插入，插入后的队列就满足题意呢？
如下示例：
    排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]
    插入的过程：
    插入[7,0]：[[7,0]]
    插入[7,1]：[[7,0],[7,1]]
    插入[6,1]：[[7,0],[6,1],[7,1]]      [6,1]会把[7,1]挤到后面，就满足了[6,1]前面只有1个比它大的
    插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]        [5,0]会把[7,0]挤到后面，就满足[5,0]前面没有比它大的
    插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]      [5,2]插到索引2的位置，此时前面一定有2个>=5的数
    插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]        [4,4]插到索引4的位置，前面一定有4个>=4的数
所以按k插入一定能满足题意，前提是身高一定是降序的，身高相同的 k小的在前面。

贪心算法：
    局部最优：优先按身高高的people的k来插入(身高相同k小的优先)。插入操作过后的people满足队列属性
    全局最优：最后都做完插入操作，整个队列满足题目队列属性
*/
class Solution {
private:
    // 按照身高降序，身高相同，k小的在前面
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1];    // k 的值就是队列插入的位置
            que.insert(que.begin() + position, people[i]);
        }
        return que;
    }
};